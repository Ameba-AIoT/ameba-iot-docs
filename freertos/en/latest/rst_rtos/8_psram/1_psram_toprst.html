

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Introduction &mdash; Ameba IoT Docs  documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=b0e775ca" />
      <link rel="stylesheet" type="text/css" href="../../_static/tabs.css?v=a5c4661c" />
      <link rel="stylesheet" type="text/css" href="../../_static/_static/custom.css" />

  
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../_static/toggleprompt.js?v=d7ede5d2"></script>
        <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
        <script src="../../_static/tabs.js?v=3030b3cb"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Thermal Senor" href="../8_thermal/0_thermal_index.html" />
    <link rel="prev" title="Pseudo-Static Random Access Memory (PSRAM)" href="0_psram_index.html" />
   
  
  <script type="text/javascript" src="../../_static/js/selector.js"></script>

  <style>
    .wy-nav-content {max-width: 1000px;} /* 设置最大宽度 */
  </style>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            Ameba IoT Docs
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../0_ameba_product/0_ameba_product_center_index.html">Products Center</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_ameba_sdk/0_ameba_sdks_index.html">Ameba SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_ameba_solutions/0_ameba_solutions_index.html">Ameba Solutions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_gcc_build_environment/0_gcc_build_index.html">0.1 GCC Build Environment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_gdb_debug/0_gdb_debug_index.html">0.2 GDB Debug</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_gcc_build_library/0_gcc_build_library_index.html">0.3 GCC Build Library</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_sdk_example/0_sdk_example_index.html">0.4 SDK Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_memory_layout/0_layout_index.html">0.5 Flash &amp; RAM Layout</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_user_config/0_usrcfg_index.html">0.6 User Config</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_tools/0_tools_index.html">0.7 Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_at_command/0_at_command_index.html">0.8 AT Command</a></li>
<li class="toctree-l1"><a class="reference internal" href="../0_file_system/0_vfs_index.html">0.9 Virtual File System</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1_mpu_cache/0_mpu_cache_index.html">1.0 MPU and Cache</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1_boot_process/0_boot_index.html">1.1 BOOT Process</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1_ota/0_ota_index.html">1.2 OTA</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1_otpc/0_otpc_index.html">1.3 OTPC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1_chipen/0_chipen_index.html">1.4 CHIPEN</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1_ipc/0_ipc_index.html">1.5 Inter Processor Communication</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1_pinmux/0_pinmux_index.html">1.6 PINMUX</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1_gpio/0_gpio_index.html">1.7 GPIO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../1_power_save/0_ps_index.html">1.9 Power Save</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_whc_wifi_bridge/0_wifi_bridge_index.html">2.1 WHC Bridge</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_whc_fullmac/0_fullmac_index.html">2.2 WHC FullMAC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_wifi_tunnel/0_wifi_tunnel_index.html">2.3 Wi-Fi R-Mesh</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_wifi_csi/0_wifi_csi_index.html">2.5 Wi-Fi CSI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../2_wifi_adaptivity_test/0_wifi_adaptivity_index.html">2.6 Wi-Fi Adaptivity Test</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_security/0_security_index.html">3.1 Security &amp; Encryption</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_trng/0_trng_index.html">3.2 True Random Number Generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_nda_huk_derivation/0_huk_derivation_index_nda.html">3.3 HUK Derivation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_nda_rdp/0_rdp_index_nda.html">3.4 RDP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_nda_rsip/0_rsip_index_nda.html">3.5 RSIP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_nda_secure_boot/0_secure_boot_index_nda.html">3.6 Secure Boot</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_nda_swd_protection/0_swd_protection_index_nda.html">3.7 SWD Protection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_nda_tfm/0_tfm_index_nda.html">3.8 Trusted Firmware-M (TF-M)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_crypto_engine/0_crypto_engine_index.html">3.9 Crypto Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_ecdsa_engine/0_ecdsa_index.html">3.a ECDSA Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_eddsa_engine/0_eddsa_index.html">3.b EDDSA Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../3_rsa_engine/0_rsa_index.html">3.c RSA Engine</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4_ai/0_ai_index.html">4.1 AI</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4_ai_voice/0_ai_voice_index.html">4.2 AIVoice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4_multimedia/0_multimedia_index.html">4.3 Multimedia</a></li>
<li class="toctree-l1"><a class="reference internal" href="../4_dsp/0_dsp_index.html">4.4 DSP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6_mass_production/0_mp_index.html">6.1 Mass Production</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6_mp_image/0_mp_image_index.html">6.2 MP Image</a></li>
<li class="toctree-l1"><a class="reference internal" href="../6_mptools/0_mptools_index.html">6.3 MP Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../7_usb/0_usb_index.html">7.1 USB Host &amp; Device</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_dmac/0_dmac_index.html">8.1 DMA Controllor</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="0_psram_index.html">8.2 PSRAM</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#throughput">Throughput</a></li>
<li class="toctree-l2"><a class="reference internal" href="#boot-from-psram">Boot from PSRAM</a></li>
<li class="toctree-l2"><a class="reference internal" href="#psram-cache-write-back-policy">PSRAM Cache “Write Back” Policy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#row-hammer">Row Hammer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#notice">Notice</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#cache-operation">Cache Operation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#dma-operation">DMA Operation</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tcem-setting">TCEM Setting</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../8_thermal/0_thermal_index.html">8.3 Thermal Meter</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_adc/0_adc_index.html">8.4 ADC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_ir/0_ir_index.html">8.5 IR</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_ledc/0_ledc_index.html">8.6 LEDC</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_cap_touch/0_cap_touch_index.html">8.7 Cap-Touch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_key_scan/0_key_scan_index.html">8.8 Key-Scan</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_rtc_io/0_rtc_io_index.html">8.9 RTC-IO</a></li>
<li class="toctree-l1"><a class="reference internal" href="../8_lcdc/0_lcdc_index.html">8.A LCDC</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Ameba IoT Docs</a>
      </nav>

      <div class="wy-nav-content">

        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="0_psram_index.html">Pseudo-Static Random Access Memory (PSRAM)</a></li>
      <li class="breadcrumb-item active">Introduction</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <span class="target" id="psram"></span><!-- 下拉菜单 -->
<div style="margin: 20px 0; text-align: left;">
    <div style="display: flex; align-items: center; gap: 10px;">
        <span style="font-size: 14px;">IC: </span>
        <select class="tab-selector" style="height: 22px; padding: 2px 8px; font-size: 13px;">
            <option value="RTL8721Dx">RTL8721Dx</option>
            <option value="RTL8720E">RTL8720E</option>
            <option value="RTL8726E">RTL8726E</option>
            <option value="RTL8730E">RTL8730E</option>
        </select>
    </div>
</div>

<!-- 修复后的 JavaScript -->
<script>
document.addEventListener("DOMContentLoaded", function() {
    const selector = document.querySelector('.tab-selector');

    selector.addEventListener('change', function() {
        const targetTab = this.value;
        const tabs = document.querySelectorAll('.sphinx-tabs-tab');
        let found = false;

        tabs.forEach(tab => {
            const tabText = tab.textContent.trim();
            if (tabText === targetTab) {
                tab.click();
                window.dispatchEvent(new Event('resize')); // 触发插件更新
                found = true;
            }
        });

        if (!found) {
            console.error("未找到选项卡:", targetTab);
        }
    });
});
</script><section id="introduction">
<h1>Introduction<a class="headerlink" href="#introduction" title="Link to this heading"></a></h1>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-0-0-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-0-0-0" name="0-0" role="tab" tabindex="0">RTL8721Dx</button><button aria-controls="panel-0-0-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-0-0-1" name="0-1" role="tab" tabindex="-1">RTL8720E</button><button aria-controls="panel-0-0-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-0-0-2" name="0-2" role="tab" tabindex="-1">RTL8726E</button><button aria-controls="panel-0-0-3" aria-selected="false" class="sphinx-tabs-tab" id="tab-0-0-3" name="0-3" role="tab" tabindex="-1">RTL8730E</button></div><div aria-labelledby="tab-0-0-0" class="sphinx-tabs-panel" id="panel-0-0-0" name="0-0" role="tabpanel" tabindex="0"><p>Pseudo-Static Random Access Memory (PSRAM) is used for high-speed transmission of the data stream. This chip communicates with PSRAM via PSRAM controller (PSRAMC). PSRAM can be accessed by KM4 and KM0, and supports execution on PSRAM.</p>
<p>The features of PSRAM are:</p>
<ul class="simple">
<li><p>Clock rate: up to 200MHz</p></li>
<li><p>Double Data Rate (DDR)</p></li>
<li><p>Read-Write Data Strobe (DQS)</p></li>
<li><p>Supports Half sleep and deep power-down mode</p></li>
<li><p>Programmable drive strength</p></li>
<li><p>Temperature Compensated Refresh</p></li>
<li><p>16/32/64/128 bytes wrap burst access</p></li>
<li><p>Distributed refresh interval varies with temperature</p></li>
<li><p>Address mapping: 0x6000_0000~0x6040_0000</p></li>
</ul>
</div><div aria-labelledby="tab-0-0-1" class="sphinx-tabs-panel" hidden="true" id="panel-0-0-1" name="0-1" role="tabpanel" tabindex="0"><p>Pseudo-Static Random Access Memory (PSRAM) is used for high-speed transmission of the data stream. This chip communicates with PSRAM via PSRAM controller (PSRAMC). PSRAM can be accessed by KM4 and KR4, and supports execution on PSRAM.</p>
<p>The features of PSRAM are:</p>
<ul class="simple">
<li><p>Clock rate: 150MHz</p></li>
<li><p>Double Data Rate (DDR)</p></li>
<li><p>Read-Write Data Strobe (DQS)</p></li>
<li><p>Supports Half sleep and deep power-down mode</p></li>
<li><p>Programmable drive strength</p></li>
<li><p>Configurable refresh rate</p></li>
<li><p>Temperature Compensated Refresh</p></li>
<li><p>16/32/64/1024 bytes wrap burst access</p></li>
</ul>
</div><div aria-labelledby="tab-0-0-2" class="sphinx-tabs-panel" hidden="true" id="panel-0-0-2" name="0-2" role="tabpanel" tabindex="0"><p>Pseudo-Static Random Access Memory (PSRAM) is used for high-speed transmission of the data stream. This chip communicates with PSRAM via PSRAM controller (PSRAMC). PSRAM can be accessed by KM4, KR4 and DSP, and supports execution on PSRAM.</p>
<p>The features of PSRAM are:</p>
<ul class="simple">
<li><p>Clock rate: 250MHz</p></li>
<li><p>Double Data Rate (DDR)</p></li>
<li><p>Read-Write Data Strobe (DQS)</p></li>
<li><p>Supports Half sleep and deep power-down mode</p></li>
<li><p>Programmable drive strength</p></li>
<li><p>Configurable refresh rate</p></li>
<li><p>Temperature Compensated Refresh</p></li>
<li><p>16/32/64/1024 bytes wrap burst access</p></li>
</ul>
</div><div aria-labelledby="tab-0-0-3" class="sphinx-tabs-panel" hidden="true" id="panel-0-0-3" name="0-3" role="tabpanel" tabindex="0"><p>Pseudo-Static Random Access Memory (PSRAM) is used for high-speed transmission of the data stream. This chip communicates with PSRAM via PSRAM controller (PSRAMC). PSRAM can be accessed by NP, LP and AP, and supports execution on PSRAM.</p>
<p>The features of PSRAM are:</p>
<ul class="simple">
<li><p>Clock rate: 250MHz</p></li>
<li><p>Density: 64M bits</p></li>
<li><p>Double Data Rate (DDR)</p></li>
<li><p>Read-Write Data Strobe (DQS)</p></li>
<li><p>Supports Half sleep and deep power-down mode</p></li>
<li><p>Programmable drive strength</p></li>
<li><p>Configurable refresh rate</p></li>
<li><p>Temperature Compensated Refresh</p></li>
<li><p>16/32/64/1024 bytes wrap burst access</p></li>
<li><p>Address mapping: 0x6000_0000~0x6080_0000</p></li>
</ul>
</div></div>
</section>
<section id="throughput">
<h1>Throughput<a class="headerlink" href="#throughput" title="Link to this heading"></a></h1>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-1-1-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-1-1-0" name="1-0" role="tab" tabindex="0">RTL8721Dx</button><button aria-controls="panel-1-1-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-1-1-1" name="1-1" role="tab" tabindex="-1">RTL8720E</button><button aria-controls="panel-1-1-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-1-1-2" name="1-2" role="tab" tabindex="-1">RTL8726E</button><button aria-controls="panel-1-1-3" aria-selected="false" class="sphinx-tabs-tab" id="tab-1-1-3" name="1-3" role="tab" tabindex="-1">RTL8730E</button></div><div aria-labelledby="tab-1-1-0" class="sphinx-tabs-panel" id="panel-1-1-0" name="1-0" role="tabpanel" tabindex="0"><p>PSRAM supports direct access and DMA access. The throughput of PSRAM is listed in the following table.</p>
<table class="docutils align-default" id="id1" style="width: 100%">
<caption><span class="caption-text">Throughput of PSRAM (200MHz)</span><a class="headerlink" href="#id1" title="Link to this table"></a></caption>
<tbody>
<tr class="row-odd"><td rowspan="2"><p>Access mode</p></td>
<td colspan="2"><p>Writing 32 bytes</p></td>
<td colspan="2"><p>Reading 32 bytes</p></td>
</tr>
<tr class="row-even"><td><p>Theory</p></td>
<td><p>Test on the KM4</p></td>
<td><p>Theory</p></td>
<td><p>Test on the KM4</p></td>
</tr>
<tr class="row-odd"><td><p>Direct access</p>
<p>(write back)</p>
</td>
<td><p>1523.81Mbps</p></td>
<td><p>(32*8)/(199.68ns)=1282.05Mbps</p></td>
<td><p>1454.55Mbps</p></td>
<td><p>(32*8)/(212.16ns)=1204.14Mbps</p></td>
</tr>
<tr class="row-even"><td><p>DMA access</p></td>
<td><p>2206.9Mbps</p></td>
<td><p>1641.03Mbps</p></td>
<td><p>2133.33Mbps</p></td>
<td><p>1172.16Mbps</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li><p>Throughput theoretical calculation:</p>
<blockquote>
<div><ul class="simple">
<li><p>The test data above takes variable initial latency, so there will be 1 or 2 times initial latency depending on RWDS.</p></li>
<li><p>The header overlaps with delay by 1T.</p></li>
<li><p>Since it is DDR PSRAM, 16T is used to transmit 32 bytes.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Direct access:</p>
<blockquote>
<div><ul class="simple">
<li><p>By default, we will assign the cache attribute to PSRAM. Therefore, when testing the access performance of PSRAM, we need to consider the cache attribute comprehensively.</p></li>
<li><p>In the operation of reading 4 bytes, if read hit (that is, the address data is stored in the cache), the CPU directly reads 4bytes from the cache. If read miss (the address data is not in the cache), it needs to read a cache line size data from PSRAM to the cache.</p></li>
<li><p>In the operation of writing 4 bytes, if write hit (the address data exists in the cache), the content of the address in the cache will be updated, and then a cacheline size will be updated to PSRAM when the cache flush. If write miss (the address to be written is not in the cache), based on the write allocate policy, the CPU will first read a cacheline size data from PSRAM to the cache, and then update the content in the cache.</p></li>
<li><p>The read / write throughput data in the table is measured based on read miss / cache flush, which requires access to PSRAM. TP of write allocate is equal to TP of read miss.</p></li>
<li><p>Instruction execution time also needs to be taken into consideration.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
<table class="docutils align-default" id="id2" style="width: 100%">
<caption><span class="caption-text">PSRAM throughput theoretical calculation</span><a class="headerlink" href="#id2" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>Writing 32 bits</p></th>
<th class="head"><p>Reading 32 bits</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Header + delay</p></td>
<td><p>[3 +22] * 4ns = 100ns</p></td>
<td><p>[3 + 23] * 4ns = 104ns</p></td>
</tr>
<tr class="row-odd"><td><p>Data transmit period</p></td>
<td><p>2 * 4ns =8ns</p></td>
<td><p>16 * 4ns = 64ns</p></td>
</tr>
<tr class="row-even"><td><p>Hardware hold</p></td>
<td><p>1 * 4ns =4ns</p></td>
<td><p>2 * 4ns = 8ns</p></td>
</tr>
<tr class="row-odd"><td><p>Total without considering instruction execution time</p></td>
<td><p>100ns + 8ns + 4ns = 112ns</p></td>
<td><p>104ns + 64ns + 8ns = 176ns</p></td>
</tr>
<tr class="row-even"><td><p>Throughput theoretical value</p></td>
<td><p>32/112ns = 285.71Mbps</p></td>
<td><p>(32x8)/176ns = 1454.55Mbps</p></td>
</tr>
</tbody>
</table>
</div><div aria-labelledby="tab-1-1-1" class="sphinx-tabs-panel" hidden="true" id="panel-1-1-1" name="1-1" role="tabpanel" tabindex="0"><div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li><p>Throughput theoretical calculation:</p>
<blockquote>
<div><ul class="simple">
<li><p>The test data above takes variable initial latency, so there will be 1 or 2 times initial latency depending on RWDS.</p></li>
<li><p>The header overlaps with delay by 1T.</p></li>
<li><p>Since it is DDR PSRAM, 16T is used to transmit 32 bytes.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Direct access:</p>
<blockquote>
<div><ul class="simple">
<li><p>By default, we will assign the cache attribute to PSRAM. Therefore, when testing the access performance of PSRAM, we need to consider the cache attribute comprehensively.</p></li>
<li><p>In the operation of reading 4 bytes, if read hit (that is, the address data is stored in the cache), the CPU directly reads 4bytes from the cache. If read miss (the address data is not in the cache), it needs to read a cache line size data from PSRAM to the cache.</p></li>
<li><p>In the operation of writing 4 bytes, if write hit (the address data exists in the cache), the content of the address in the cache will be updated, and then a cacheline size will be updated to PSRAM when the cache flush. If write miss (the address to be written is not in the cache), based on the write allocate policy, the CPU will first read a cacheline size data from PSRAM to the cache, and then update the content in the cache.</p></li>
<li><p>The read / write throughput data in the table is measured based on read miss / cache flush, which requires access to PSRAM. TP of write allocate is equal to TP of read miss.</p></li>
<li><p>Instruction execution time also needs to be taken into consideration.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<table class="docutils align-default" id="id4" style="width: 100%">
<caption><span class="caption-text">PSRAM throughput theoretical calculation</span><a class="headerlink" href="#id4" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>Writing 32 bits</p></th>
<th class="head"><p>Reading 32 bits</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Header + delay</p></td>
<td><p>[3 + (6 or 12) -1] * (1000/150)ns</p></td>
<td><p>[3 + (6 or 12) -1] * (1000/150)ns</p></td>
</tr>
<tr class="row-odd"><td><p>Data transmit period</p></td>
<td><p>16 * (1000/150)ns</p></td>
<td><p>16 * (1000/150)ns</p></td>
</tr>
<tr class="row-even"><td><p>Hardware hold</p></td>
<td><p>1 * (1000/150)ns</p></td>
<td><p>2 * (1000/150)ns</p></td>
</tr>
<tr class="row-odd"><td><p>Total without considering</p>
<p>instruction execution time</p>
</td>
<td><p>[(8 or 14) + 16 +1] * (1000/150)ns = (166.667 or 206.667)ns</p></td>
<td><p>[(8 or 14) + 16 +2] * (1000/150)ns = (173.333 or 213.333)ns</p></td>
</tr>
<tr class="row-even"><td><p>Throughput theoretical value</p></td>
<td><p>32*8/(166.667 or 206.667)ns = (1536 or 1238.71)Mbps</p></td>
<td><p>(32*8)/(173.333 or 213.333)ns = (1476.923 or 1200)Mbps</p></td>
</tr>
</tbody>
</table>
</div>
</div><div aria-labelledby="tab-1-1-2" class="sphinx-tabs-panel" hidden="true" id="panel-1-1-2" name="1-2" role="tabpanel" tabindex="0"><div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li><p>Throughput theoretical calculation:</p>
<blockquote>
<div><ul class="simple">
<li><p>The test data above takes variable initial latency, so there will be 1 or 2 times initial latency depending on RWDS.</p></li>
<li><p>The header overlaps with delay by 1T.</p></li>
<li><p>Since it is DDR PSRAM, 16T is used to transmit 32 bytes.</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Direct access:</p>
<blockquote>
<div><ul class="simple">
<li><p>By default, we will assign the cache attribute to PSRAM. Therefore, when testing the access performance of PSRAM, we need to consider the cache attribute comprehensively.</p></li>
<li><p>In the operation of reading 4 bytes, if read hit (that is, the address data is stored in the cache), the CPU directly reads 4bytes from the cache. If read miss (the address data is not in the cache), it needs to read a cache line size data from PSRAM to the cache.</p></li>
<li><p>In the operation of writing 4 bytes, if write hit (the address data exists in the cache), the content of the address in the cache will be updated, and then a cacheline size will be updated to PSRAM when the cache flush. If write miss (the address to be written is not in the cache), based on the write allocate policy, the CPU will first read a cacheline size data from PSRAM to the cache, and then update the content in the cache.</p></li>
<li><p>The read / write throughput data in the table is measured based on read miss / cache flush, which requires access to PSRAM. TP of write allocate is equal to TP of read miss.</p></li>
<li><p>Instruction execution time also needs to be taken into consideration.</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<table class="docutils align-default" id="id6" style="width: 100%">
<caption><span class="caption-text">PSRAM throughput theoretical calculation</span><a class="headerlink" href="#id6" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>Writing 32 bits</p></th>
<th class="head"><p>Reading 32 bits</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Header + delay</p></td>
<td><p>[3 +(7 or 14)-1] * 4ns = 36 or 64ns</p></td>
<td><p>[3 + (7 or 14)-1] * 4ns = 36 or 64ns</p></td>
</tr>
<tr class="row-odd"><td><p>Data transmit period</p></td>
<td><p>16 * 4ns =64ns</p></td>
<td><p>16 * 4ns = 64ns</p></td>
</tr>
<tr class="row-even"><td><p>Hardware hold</p></td>
<td><p>1 * 4ns =4ns</p></td>
<td><p>2 * 4ns = 8ns</p></td>
</tr>
<tr class="row-odd"><td><p>Total without considering</p>
<p>instruction execution time</p>
</td>
<td><p>36 or 64ns + 64ns + 4ns = 104 or 132ns</p></td>
<td><p>36 or 64ns + 64ns + 8ns = 108 or 136ns</p></td>
</tr>
<tr class="row-even"><td><p>Throughput theoretical value</p></td>
<td><p>32*8/104 or 132ns =2461.538 or 1939.394Mbps</p></td>
<td><p>(32*8)/108 or 136ns = 2370.37 or 1882.353Mbps</p></td>
</tr>
</tbody>
</table>
</div>
</div><div aria-labelledby="tab-1-1-3" class="sphinx-tabs-panel" hidden="true" id="panel-1-1-3" name="1-3" role="tabpanel" tabindex="0"><p>PSRAM supports direct access and DMA access. The throughput of PSRAM is listed in the following table.</p>
<table class="docutils align-default" id="id7" style="width: 100%">
<caption><span class="caption-text">Throughput of PSRAM (250MHz)</span><a class="headerlink" href="#id7" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head" rowspan="2"><p>Access mode</p></th>
<th class="head" colspan="2"><p>Writing 32 bytes</p></th>
<th class="head" colspan="2"><p>Reading 32 bytes</p></th>
</tr>
<tr class="row-even"><th class="head"><p>Theory (Mbps)</p></th>
<th class="head"><p>Test on NP (Mbps)</p></th>
<th class="head"><p>Theory (Mbps)</p></th>
<th class="head"><p>Test on NP (Mbps)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-odd"><td><p>Direct access</p>
<p>(write back)</p>
</td>
<td rowspan="2"><p>1939.394</p></td>
<td><p>(32*8)/(123ns)=2081.30</p></td>
<td rowspan="2"><p>1882.353</p></td>
<td><p>(32*8)/(152ns)=1684.21</p></td>
</tr>
<tr class="row-even"><td><p>DMA access</p></td>
<td><p>(32*8)/(180ns)=1422.22</p></td>
<td><p>(32*8)/(175.60ns)=1457.85</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul class="simple">
<li><p>Throughput theoretical calculation:</p></li>
<li><p>The test data above takes fixed initial latency, so there will be 2 times initial latency depending on RWDS.</p></li>
<li><p>The header overlaps with delay by 1T.</p></li>
<li><p>Since it is DDR PSRAM, 16T is used to transmit 32 bytes.</p></li>
<li><p>Direct access:</p></li>
<li><p>By default, we will assign the cache attribute to PSRAM. Therefore, when testing the access performance of PSRAM, we need to consider the cache attribute comprehensively.</p></li>
<li><p>In the operation of reading 4 bytes, if read hit (that is, the address data is stored in the cache), the CPU directly reads 4bytes from the cache. If read miss (the address data is not in the cache), it needs to read a cache line size data from PSRAM to the cache.</p></li>
<li><p>In the operation of writing 4 bytes, if write hit (the address data exists in the cache), the content of the address in the cache will be updated, and then a cacheline size will be updated to PSRAM when the cache flush. If write miss ( the address to be written is not in the cache), based on the write allocate policy, the CPU will first read a cacheline size data from PSRAM to the cache, and then update the content in the cache.</p></li>
<li><p>The read / write throughput data in the table is measured based on read miss / cache flush, which requires access to PSRAM. TP of write allocate is equal to TP of read miss.</p></li>
<li><p>Instruction execution time also needs to be taken into consideration.</p></li>
</ul>
</div>
<table class="docutils align-default" id="id8" style="width: 100%">
<caption><span class="caption-text">PSRAM throughput theoretical calculation</span><a class="headerlink" href="#id8" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><p>Item</p></th>
<th class="head"><p>Writing 32 bits (In fact, writing 32 bytes)</p></th>
<th class="head"><p>Reading 32 bits (In fact, reading 32 bytes)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Header + delay</p></td>
<td><p>[3 +(14-1)] * 4ns = 64ns</p></td>
<td><p>[3 + (14-1)] * 4ns = 64ns</p></td>
</tr>
<tr class="row-odd"><td><p>Data transmit period</p></td>
<td><p>16 * 4ns =64ns</p></td>
<td><p>16 * 4ns = 64ns</p></td>
</tr>
<tr class="row-even"><td><p>Hardware hold</p></td>
<td><p>1 * 4ns =4ns</p></td>
<td><p>2 * 4ns = 8ns</p></td>
</tr>
<tr class="row-odd"><td><p>Total without considering</p>
<p>instruction execution time</p>
</td>
<td><p>64ns + 64ns + 4ns = 132ns</p></td>
<td><p>64ns + 64ns + 8ns = 136ns</p></td>
</tr>
<tr class="row-even"><td><p>Throughput theoretical value</p></td>
<td><p>(32*8) / 132ns = 1939.394Mbps</p></td>
<td><p>(32*8) / 136ns = 1882.353Mbps</p></td>
</tr>
</tbody>
</table>
</div></div>
</section>
<section id="boot-from-psram">
<h1>Boot from PSRAM<a class="headerlink" href="#boot-from-psram" title="Link to this heading"></a></h1>
<p>If the PSRAM is embedded in the chip, follow these steps to boot from PSRAM in the SDK.</p>
<ol class="arabic simple">
<li><p>Enable the power supply of PSRAM in the bootloader</p></li>
<li><p>Initialize the PSRAM controller, PSRAM PHY and PSRAM device to synchronize the relevant parameters</p></li>
<li><p>Calibrate the PSRAM</p></li>
</ol>
<div class="highlight-C notranslate"><div class="highlight"><pre><span></span><span class="n">RCC_PeriphClockCmd</span><span class="p">(</span><span class="n">APBPeriph_PSRAM</span><span class="p">,</span><span class="w"> </span><span class="n">APBPeriph_PSRAM_CLOCK</span><span class="p">,</span><span class="w"> </span><span class="n">ENABLE</span><span class="p">);</span>
<span class="n">DBG_PRINT</span><span class="p">(</span><span class="n">MODULE_BOOT</span><span class="p">,</span><span class="w"> </span><span class="n">LEVEL_INFO</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Init PSRAM</span><span class="se">\r\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">BOOT_PSRAM_Init</span><span class="p">();</span>
</pre></div>
</div>
</section>
<section id="psram-cache-write-back-policy">
<h1>PSRAM Cache “Write Back” Policy<a class="headerlink" href="#psram-cache-write-back-policy" title="Link to this heading"></a></h1>
<p>When a cache hit occurs on a store access, the data is only written to the cache. Data in the cache can therefore be more up-to-date than data in memory. Any such data is written back to memory when the cache line is cleaned or reallocated. Another common term for a write-back cache is a copy-back cache.
By default, we will assign the cache attribute to PSRAM. For CPU, only when read miss/cache flush/write allocate will access PSRAM, one cache line at a time.</p>
<section id="row-hammer">
<h2>Row Hammer<a class="headerlink" href="#row-hammer" title="Link to this heading"></a></h2>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-2-2-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-2-2-0" name="2-0" role="tab" tabindex="0">RTL8721Dx</button><button aria-controls="panel-2-2-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-2-2-1" name="2-1" role="tab" tabindex="-1">RTL8720E</button><button aria-controls="panel-2-2-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-2-2-2" name="2-2" role="tab" tabindex="-1">RTL8726E</button><button aria-controls="panel-2-2-3" aria-selected="false" class="sphinx-tabs-tab" id="tab-2-2-3" name="2-3" role="tab" tabindex="-1">RTL8730E</button></div><div aria-labelledby="tab-2-2-0" class="sphinx-tabs-panel" id="panel-2-2-0" name="2-0" role="tabpanel" tabindex="0"><p>With the increasing density of DRAM, its memory cells become smaller and smaller, and the stored charge decreases. As a result, the noise tolerance between memory cells is reduced, resulting in the interaction of charges between two independent memory cells. Row hammer is caused by this defect in the design of memory hardware chip. Its principle is to repeatedly read and write the peer address in DRAM memory unit, so that the charge leakage occurs in adjacent rows, and the bit reversal phenomenon occurs in adjacent rows, that is, 0 is reversed to 1, and 1 is reversed to 0.</p>
<p>Therefore, when a large number of accesses are made to PSRAM in a short time, if the refresh frequency is not enough, the MEM space of every 2K (i.e. two rows) will affect each other. When we perform a large number of continuous write operations on a line, the charges of adjacent lines will be affected and the value will change.</p>
</div><div aria-labelledby="tab-2-2-1" class="sphinx-tabs-panel" hidden="true" id="panel-2-2-1" name="2-1" role="tabpanel" tabindex="0"><p>With the increasing density of DRAM, its memory cells become smaller and smaller, and the stored charge decreases. As a result, the noise tolerance between memory cells is reduced, resulting in the interaction of charges between two independent memory cells. Row hammer is caused by this defect in the design of memory hardware chip. Its principle is to repeatedly read and write the peer address in DRAM memory unit, so that the charge leakage occurs in adjacent rows, and the bit reversal phenomenon occurs in adjacent rows, that is, 0 is reversed to 1, and 1 is reversed to 0.</p>
<p>Therefore, when a large number of accesses are made to PSRAM in a short time, if the refresh frequency is not enough, the MEM space of every 2K (i.e. two rows) will affect each other. When we perform a large number of continuous write operations on a line, the charges of adjacent lines will be affected and the value will change.</p>
</div><div aria-labelledby="tab-2-2-2" class="sphinx-tabs-panel" hidden="true" id="panel-2-2-2" name="2-2" role="tabpanel" tabindex="0"><p>With the increasing density of DRAM, its memory cells become smaller and smaller, and the stored charge decreases. As a result, the noise tolerance between memory cells is reduced, resulting in the interaction of charges between two independent memory cells. Row hammer is caused by this defect in the design of memory hardware chip. Its principle is to repeatedly read and write the peer address in DRAM memory unit, so that the charge leakage occurs in adjacent rows, and the bit reversal phenomenon occurs in adjacent rows, that is, 0 is reversed to 1, and 1 is reversed to 0.</p>
<p>Therefore, when a large number of accesses are made to PSRAM in a short time, if the refresh frequency is not enough, the MEM space of every 2K (i.e. two rows) will affect each other. When we perform a large number of continuous write operations on a line, the charges of adjacent lines will be affected and the value will change.</p>
</div><div aria-labelledby="tab-2-2-3" class="sphinx-tabs-panel" hidden="true" id="panel-2-2-3" name="2-3" role="tabpanel" tabindex="0"><p>With the increasing density of DRAM, its memory cells become smaller and smaller, and the stored charge decreases. As a result, the noise tolerance between memory cells is reduced, resulting in the interaction of charges between two independent memory cells. Row hammer is caused by this defect in the design of memory hardware chip. Its principle is to repeatedly read and write the peer address in DRAM memory unit, so that the charge leakage occurs in adjacent rows, and the bit reversal phenomenon occurs in adjacent rows, that is, 0 is reversed to 1, and 1 is reversed to 0.</p>
<p>Therefore, when a large number of accesses are made to PSRAM in a short time, if the refresh frequency is not enough, the MEM space of every 2K (i.e. two rows) will affect each other. When we perform a large number of continuous write operations on a line, the charges of adjacent lines will be affected and the value will change.</p>
<p>Row hammer is an inherent weakness of PSRAM. If the cache is not turned on, it may be hit by excessive load. When the cache is turned on, we have tested that APM PSRAM is safe on AP. The test conditions are as follows:</p>
<ol class="arabic simple">
<li><p>AP clock is 1.2GHz.</p></li>
<li><p>In write back mode.</p></li>
<li><p>Every 4K bytes of memory is a group, write the first 800 bytes 8W times (cache flush for each 800 bytes), and then check whether the values of other unwritten memories have changed by reading.</p></li>
</ol>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want to set memory to non-cache attribute through MMU or MPU, take the boundary of row hammer into consideration.</p>
</div>
</div></div>
</section>
<section id="notice">
<h2>Notice<a class="headerlink" href="#notice" title="Link to this heading"></a></h2>
<section id="cache-operation">
<h3>Cache Operation<a class="headerlink" href="#cache-operation" title="Link to this heading"></a></h3>
<p>On the “Write Back” policy, the synchronization operations need to be taken between cache and PSRAM to keep content consistency, especially for multiple access by different sources, e.g. CPU, serial ports and peripherals.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-3-3-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-3-3-0" name="3-0" role="tab" tabindex="0">RTL8721Dx</button><button aria-controls="panel-3-3-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-3-3-1" name="3-1" role="tab" tabindex="-1">RTL8720E</button><button aria-controls="panel-3-3-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-3-3-2" name="3-2" role="tab" tabindex="-1">RTL8726E</button><button aria-controls="panel-3-3-3" aria-selected="false" class="sphinx-tabs-tab" id="tab-3-3-3" name="3-3" role="tab" tabindex="-1">RTL8730E</button></div><div aria-labelledby="tab-3-3-0" class="sphinx-tabs-panel" id="panel-3-3-0" name="3-0" role="tabpanel" tabindex="0"><p>As the cache line of KM4/KM0 cache is 32 bytes, and cache operations are all based on the cache line. So the buffer size and buffer starting address are recommended to be 32/64 bytes aligned to avoid synchronization issues.</p>
</div><div aria-labelledby="tab-3-3-1" class="sphinx-tabs-panel" hidden="true" id="panel-3-3-1" name="3-1" role="tabpanel" tabindex="0"><p>As the cache line of KM4/KR4 cache line is 32 bytes, and cache operations are all based on the cache line. So the buffer size and buffer starting address are recommended to be 32 bytes aligned to avoid synchronization issues.</p>
</div><div aria-labelledby="tab-3-3-2" class="sphinx-tabs-panel" hidden="true" id="panel-3-3-2" name="3-2" role="tabpanel" tabindex="0"><p>As the cache line of KM4/KR4 cache line is 32 bytes, DSP cache line is 128 bytes, and cache operations are all based on the cache line. So the buffer size and buffer starting address are recommended to be 32/128 bytes aligned to avoid synchronization issues.</p>
</div><div aria-labelledby="tab-3-3-3" class="sphinx-tabs-panel" hidden="true" id="panel-3-3-3" name="3-3" role="tabpanel" tabindex="0"><p>As the cache lines of NP/LP cache are 32 bytes, AP cache is 64 bytes, and cache operations are all based on the cache line. So the buffer size and buffer starting address are recommended to be 64 bytes aligned to avoid synchronization issues.</p>
</div></div>
</section>
<section id="dma-operation">
<h3>DMA Operation<a class="headerlink" href="#dma-operation" title="Link to this heading"></a></h3>
<p>The following steps should be added when executing DMA Rx/Tx.</p>
<table class="docutils align-default" style="width: 100%">
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Step</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>DMA Rx</p></td>
<td><ol class="arabic">
<li><p>Prepare Rx buffer</p></li>
<li><p>Do <code class="xref py py-func docutils literal notranslate"><span class="pre">DCache_CleanInvalidate()</span></code> to avoid cache data write back during DMA Rx</p></li>
<li><p>Do DMA Rx config</p></li>
<li><p>Trigger DMA Rx interrupt</p></li>
<li><p>Do <code class="xref py py-func docutils literal notranslate"><span class="pre">DCache_Invalidate()</span></code> in Rx Done Handler to clean the old data</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>During GDMA transmission, it is forbidden to write or cache flush DST buffer.
(Taking <code class="file docutils literal notranslate"><em><span class="pre">SDK</span></em><span class="pre">\component\example\peripheral\raw\uart\uart_dma_stream\src\main.c</span></code> for example,
<code class="xref py py-mod docutils literal notranslate"><span class="pre">uart_recv_string_done</span></code> is DMA Rx Done Interrupt Handler)</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">u32</span><span class="w"> </span><span class="nf">uart_recv_string_done</span><span class="p">(</span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">  </span><span class="n">UNUSED</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="w">  </span><span class="cm">/* To solve the cache consistency problem, DMA mode needs it */</span>
<span class="w">  </span><span class="n">DCache_Invalidate</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">rx_buf</span><span class="p">,</span><span class="w"> </span><span class="n">SRX_BUF_SZ</span><span class="p">);</span>
<span class="w">  </span><span class="n">dma_free</span><span class="p">();</span>
<span class="w">  </span><span class="n">rx_done</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w"> </span><span class="p">}</span>
</pre></div>
</div>
</div>
</li>
<li><p>CPU reads Rx buffer</p></li>
</ol>
</td>
</tr>
<tr class="row-odd"><td><p>DMA Tx</p></td>
<td><ol class="arabic simple">
<li><p>CPU prepares Tx buffer data</p></li>
<li><p>Do <code class="xref py py-func docutils literal notranslate"><span class="pre">DCache_CleanInvalidate()</span></code> for Tx buffer to synchronize the data</p></li>
<li><p>Do DMA Tx configuration</p></li>
<li><p>Trigger DMA Tx interrupt</p></li>
</ol>
</td>
</tr>
</tbody>
</table>
<p>In SDK, only the example of one-time xxx_GDMA_Init one-time transmission is illustrated. Step 2 is included in <code class="docutils literal notranslate"><span class="pre">xxx_GDMA_Init</span></code> by default.</p>
<p>If you need multi-time DMA Tx/Rx with only one-time xxx_GDMA_Init, <code class="docutils literal notranslate"><span class="pre">DCache_CleanInvalidate()</span></code> should be called every time before DMA transmission starts.</p>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-4-4-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-4-4-0" name="4-0" role="tab" tabindex="0">RTL8721Dx</button><button aria-controls="panel-4-4-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-4-4-1" name="4-1" role="tab" tabindex="-1">RTL8720E</button><button aria-controls="panel-4-4-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-4-4-2" name="4-2" role="tab" tabindex="-1">RTL8726E</button><button aria-controls="panel-4-4-3" aria-selected="false" class="sphinx-tabs-tab" id="tab-4-4-3" name="4-3" role="tab" tabindex="-1">RTL8730E</button></div><div aria-labelledby="tab-4-4-0" class="sphinx-tabs-panel" id="panel-4-4-0" name="4-0" role="tabpanel" tabindex="0"><table class="docutils align-default" style="width: 100%">
<tbody>
<tr class="row-odd"><td><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOL</span><span class="w"> </span><span class="nf">UART_TXGDMA_Init</span><span class="p">(</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">UartIndex</span><span class="p">,</span>
<span class="w">   </span><span class="n">GDMA_InitTypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">GDMA_InitStruct</span><span class="p">,</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">CallbackData</span><span class="p">,</span>
<span class="w">   </span><span class="n">IRQ_FUN</span><span class="w"> </span><span class="n">CallBackFunc</span><span class="p">,</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">pTxBuf</span><span class="p">,</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">TxCount</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">GdmaChnl</span><span class="p">;</span>

<span class="w">   </span><span class="n">assert_param</span><span class="p">(</span><span class="n">GDMA_InitStruct</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">   </span><span class="n">DCache_CleanInvalidate</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">pTxBuf</span><span class="p">,</span><span class="w"> </span><span class="n">TxCount</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOL</span><span class="w"> </span><span class="nf">UART_RXGDMA_Init</span><span class="p">(</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">UartIndex</span><span class="p">,</span>
<span class="w">   </span><span class="n">GDMA_InitTypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">GDMA_InitStruct</span><span class="p">,</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">CallbackData</span><span class="p">,</span>
<span class="w">   </span><span class="n">IRQ_FUN</span><span class="w"> </span><span class="n">CallBackFunc</span><span class="p">,</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">pRxBuf</span><span class="p">,</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">RxCount</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">GdmaChnl</span><span class="p">;</span>
<span class="w">   </span><span class="n">UART_TypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">UARTx</span><span class="p">;</span>
<span class="w">   </span><span class="n">assert_param</span><span class="p">(</span><span class="n">GDMA_InitStruct</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">   </span><span class="n">DCache_CleanInvalidate</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">pRxBuf</span><span class="p">,</span><span class="w"> </span><span class="n">RxCount</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div><div aria-labelledby="tab-4-4-1" class="sphinx-tabs-panel" hidden="true" id="panel-4-4-1" name="4-1" role="tabpanel" tabindex="0"><table class="docutils align-default" style="width: 100%">
<tbody>
<tr class="row-odd"><td><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOL</span><span class="w"> </span><span class="nf">UART_TXGDMA_Init</span><span class="p">(</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">UartIndex</span><span class="p">,</span>
<span class="w">   </span><span class="n">GDMA_InitTypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">GDMA_InitStruct</span><span class="p">,</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">CallbackData</span><span class="p">,</span>
<span class="w">   </span><span class="n">IRQ_FUN</span><span class="w"> </span><span class="n">CallBackFunc</span><span class="p">,</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">pTxBuf</span><span class="p">,</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">TxCount</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">GdmaChnl</span><span class="p">;</span>

<span class="w">   </span><span class="n">assert_param</span><span class="p">(</span><span class="n">GDMA_InitStruct</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">   </span><span class="n">DCache_CleanInvalidate</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">pTxBuf</span><span class="p">,</span><span class="w"> </span><span class="n">TxCount</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOL</span><span class="w"> </span><span class="nf">UART_RXGDMA_Init</span><span class="p">(</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">UartIndex</span><span class="p">,</span>
<span class="w">   </span><span class="n">GDMA_InitTypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">GDMA_InitStruct</span><span class="p">,</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">CallbackData</span><span class="p">,</span>
<span class="w">   </span><span class="n">IRQ_FUN</span><span class="w"> </span><span class="n">CallBackFunc</span><span class="p">,</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">pRxBuf</span><span class="p">,</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">RxCount</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">GdmaChnl</span><span class="p">;</span>
<span class="w">   </span><span class="n">UART_TypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">UARTx</span><span class="p">;</span>
<span class="w">   </span><span class="n">assert_param</span><span class="p">(</span><span class="n">GDMA_InitStruct</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">   </span><span class="n">DCache_CleanInvalidate</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">pRxBuf</span><span class="p">,</span><span class="w"> </span><span class="n">RxCount</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div><div aria-labelledby="tab-4-4-2" class="sphinx-tabs-panel" hidden="true" id="panel-4-4-2" name="4-2" role="tabpanel" tabindex="0"><table class="docutils align-default" style="width: 100%">
<tbody>
<tr class="row-odd"><td><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOL</span><span class="w"> </span><span class="nf">UART_TXGDMA_Init</span><span class="p">(</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">UartIndex</span><span class="p">,</span>
<span class="w">   </span><span class="n">GDMA_InitTypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">GDMA_InitStruct</span><span class="p">,</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">CallbackData</span><span class="p">,</span>
<span class="w">   </span><span class="n">IRQ_FUN</span><span class="w"> </span><span class="n">CallBackFunc</span><span class="p">,</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">pTxBuf</span><span class="p">,</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">TxCount</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">GdmaChnl</span><span class="p">;</span>

<span class="w">   </span><span class="n">assert_param</span><span class="p">(</span><span class="n">GDMA_InitStruct</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">   </span><span class="n">DCache_CleanInvalidate</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">pTxBuf</span><span class="p">,</span><span class="w"> </span><span class="n">TxCount</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOL</span><span class="w"> </span><span class="nf">UART_RXGDMA_Init</span><span class="p">(</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">UartIndex</span><span class="p">,</span>
<span class="w">   </span><span class="n">GDMA_InitTypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">GDMA_InitStruct</span><span class="p">,</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">CallbackData</span><span class="p">,</span>
<span class="w">   </span><span class="n">IRQ_FUN</span><span class="w"> </span><span class="n">CallBackFunc</span><span class="p">,</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">pRxBuf</span><span class="p">,</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">RxCount</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">GdmaChnl</span><span class="p">;</span>
<span class="w">   </span><span class="n">UART_TypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">UARTx</span><span class="p">;</span>
<span class="w">   </span><span class="n">assert_param</span><span class="p">(</span><span class="n">GDMA_InitStruct</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">   </span><span class="n">DCache_CleanInvalidate</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">pRxBuf</span><span class="p">,</span><span class="w"> </span><span class="n">RxCount</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div><div aria-labelledby="tab-4-4-3" class="sphinx-tabs-panel" hidden="true" id="panel-4-4-3" name="4-3" role="tabpanel" tabindex="0"><table class="docutils align-default" style="width: 100%">
<tbody>
<tr class="row-odd"><td><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOL</span><span class="w"> </span><span class="nf">UART_TXGDMA_Init</span><span class="p">(</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">UartIndex</span><span class="p">,</span>
<span class="w">   </span><span class="n">GDMA_InitTypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">GDMA_InitStruct</span><span class="p">,</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">CallbackData</span><span class="p">,</span>
<span class="w">   </span><span class="n">IRQ_FUN</span><span class="w"> </span><span class="n">CallbackFunc</span><span class="p">,</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">pTxBuf</span><span class="p">,</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">TxCount</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">GdmaChnl</span><span class="p">;</span>

<span class="w">   </span><span class="n">assert_param</span><span class="p">(</span><span class="n">GDMA_InitStruct</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">   </span><span class="n">DCache_CleanInvalidate</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">pTxBuf</span><span class="p">,</span><span class="w"> </span><span class="n">TxCount</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
<td><div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="n">BOOL</span><span class="w"> </span><span class="nf">UART_RXGDMA_Init</span><span class="p">(</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">UartIndex</span><span class="p">,</span>
<span class="w">   </span><span class="n">GDMA_InitTypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">GDMA_InitStruct</span><span class="p">,</span>
<span class="w">   </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">CallbackData</span><span class="p">,</span>
<span class="w">   </span><span class="n">IRQ_FUN</span><span class="w"> </span><span class="n">CallbackFunc</span><span class="p">,</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="o">*</span><span class="n">pRxBuf</span><span class="p">,</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">RxCount</span>
<span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="n">u8</span><span class="w"> </span><span class="n">GdmaChnl</span><span class="p">;</span>
<span class="w">   </span><span class="n">UART_TypeDef</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">UARTx</span><span class="p">;</span>
<span class="w">   </span><span class="n">assert_param</span><span class="p">(</span><span class="n">GDMA_InitStruct</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span>

<span class="w">   </span><span class="n">DCache_CleanInvalidate</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">pRxBuf</span><span class="p">,</span><span class="w"> </span><span class="n">RxCount</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</td>
</tr>
</tbody>
</table>
</div></div>
</section>
</section>
</section>
<section id="tcem-setting">
<h1>TCEM Setting<a class="headerlink" href="#tcem-setting" title="Link to this heading"></a></h1>
<div class="sphinx-tabs docutils container">
<div aria-label="Tabbed content" class="closeable" role="tablist"><button aria-controls="panel-5-5-0" aria-selected="true" class="sphinx-tabs-tab" id="tab-5-5-0" name="5-0" role="tab" tabindex="0">RTL8721Dx</button><button aria-controls="panel-5-5-1" aria-selected="false" class="sphinx-tabs-tab" id="tab-5-5-1" name="5-1" role="tab" tabindex="-1">RTL8720E</button><button aria-controls="panel-5-5-2" aria-selected="false" class="sphinx-tabs-tab" id="tab-5-5-2" name="5-2" role="tab" tabindex="-1">RTL8726E</button><button aria-controls="panel-5-5-3" aria-selected="false" class="sphinx-tabs-tab" id="tab-5-5-3" name="5-3" role="tab" tabindex="-1">RTL8730E</button></div><div aria-labelledby="tab-5-5-0" class="sphinx-tabs-panel" id="panel-5-5-0" name="5-0" role="tabpanel" tabindex="0"><p>The <code class="docutils literal notranslate"><span class="pre">TPR0[24:31]</span></code> (CS_TCEM) provides the function that when the CSN low pulse width is equal to <cite>(CS_TCEM * 32)*busclk</cite>, the SPI Flash Controller will automatically chop the current transmission and pull CS up.</p>
<p>Winbond:</p>
<ul class="simple">
<li><p>When the temperature is less than 85°C, PSRAM refresh the intern cell array using normal rate (4us).</p></li>
<li><p>When the temperature is greater than 85°C and less than 125°C, PSRAM refresh the internal cell array using faster rate (1us). This sets an upper limit on the length of read and write transactions so that the automatic distributed refresh operation can be done between transactions. This limit is called the CS# low maximum time (tCSM) and the tCSM will be equal to the maximum distributed refresh interval.</p></li>
<li><p>So when the temperature is less than 85°C, for higher performance, we recommend that <code class="docutils literal notranslate"><span class="pre">CS_TCEM</span></code> should be equal to <cite>4us/busclk/32</cite>. When the temperature is greater than 85°C, the value should be equal to <cite>1us/busclk/32</cite>.</p></li>
</ul>
<p>APM:</p>
<ul class="simple">
<li><p>APM is in extended mode by default, so it always keeps fast refresh (1us). Here, <code class="docutils literal notranslate"><span class="pre">CS_TCEM</span></code> is recommended equal to <cite>1us/busclk/32</cite>.</p></li>
</ul>
</div><div aria-labelledby="tab-5-5-1" class="sphinx-tabs-panel" hidden="true" id="panel-5-5-1" name="5-1" role="tabpanel" tabindex="0"><p>The <code class="docutils literal notranslate"><span class="pre">TPR0[24:31]</span></code> (CS_TCEM) provides the function that when the CSN low pulse width is equal to <cite>(CS_TCEM * 32)*busclk</cite>, the SPI Flash Controller will automatically chop the current transmission and pull CS up.</p>
<p>Winbond:</p>
<ul class="simple">
<li><p>When the temperature is less than 85°C, PSRAM refresh the intern cell array using normal rate (4us).</p></li>
<li><p>When the temperature is greater than 85°C and less than 125°C, PSRAM refresh the internal cell array using faster rate (1us). This sets an upper limit on the length of read and write transactions so that the automatic distributed refresh operation can be done between transactions. This limit is called the CS# low maximum time (tCSM) and the tCSM will be equal to the maximum distributed refresh interval.</p></li>
<li><p>So when the temperature is less than 85°C, for higher performance, we recommend that <code class="docutils literal notranslate"><span class="pre">CS_TCEM</span></code> should be equal to <cite>4us/busclk/32</cite>. When the temperature is greater than 85°C, the value should be equal to <cite>1us/busclk/32</cite>.</p></li>
</ul>
<p>APM:</p>
<ul class="simple">
<li><p>APM is in extended mode by default, so it always keeps fast refresh (1us). Here, <code class="docutils literal notranslate"><span class="pre">CS_TCEM</span></code> is recommended equal to <cite>1us/busclk/32</cite>.</p></li>
</ul>
</div><div aria-labelledby="tab-5-5-2" class="sphinx-tabs-panel" hidden="true" id="panel-5-5-2" name="5-2" role="tabpanel" tabindex="0"><p>The <code class="docutils literal notranslate"><span class="pre">TPR0[24:31]</span></code> (CS_TCEM) provides the function that when the CSN low pulse width is equal to <cite>(CS_TCEM * 32)*busclk</cite>, the SPI Flash Controller will automatically chop the current transmission and pull CS up.</p>
<p>Winbond:</p>
<ul class="simple">
<li><p>When the temperature is less than 85°C, PSRAM refresh the intern cell array using normal rate (4us).</p></li>
<li><p>When the temperature is greater than 85°C and less than 125°C, PSRAM refresh the internal cell array using faster rate (1us). This sets an upper limit on the length of read and write transactions so that the automatic distributed refresh operation can be done between transactions. This limit is called the CS# low maximum time (tCSM) and the tCSM will be equal to the maximum distributed refresh interval.</p></li>
<li><p>So when the temperature is less than 85°C, for higher performance, we recommend that <code class="docutils literal notranslate"><span class="pre">CS_TCEM</span></code> should be equal to <cite>4us/busclk/32</cite>. When the temperature is greater than 85°C, the value should be equal to <cite>1us/busclk/32</cite>.</p></li>
</ul>
<p>APM:</p>
<ul class="simple">
<li><p>APM is in extended mode by default, so it always keeps fast refresh (1us). Here, <code class="docutils literal notranslate"><span class="pre">CS_TCEM</span></code> is recommended equal to <cite>1us/busclk/32</cite>.</p></li>
</ul>
</div><div aria-labelledby="tab-5-5-3" class="sphinx-tabs-panel" hidden="true" id="panel-5-5-3" name="5-3" role="tabpanel" tabindex="0"><p>RTL8730E dont need this.</p>
</div></div>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="0_psram_index.html" class="btn btn-neutral float-left" title="Pseudo-Static Random Access Memory (PSRAM)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../8_thermal/0_thermal_index.html" class="btn btn-neutral float-right" title="Thermal Senor" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Realsil.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>

      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 



</body>
</html>